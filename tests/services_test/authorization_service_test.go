package service_test

import (
	"errors"
	"github.com/manuelrojas19/go-oauth2-server/autogenerated/mocks"
	"github.com/manuelrojas19/go-oauth2-server/services"
	"go.uber.org/mock/gomock"
	"testing"
	"time"

	"github.com/manuelrojas19/go-oauth2-server/configuration"
	"github.com/manuelrojas19/go-oauth2-server/oauth"
	"github.com/manuelrojas19/go-oauth2-server/oauth/responsetype"
	"github.com/manuelrojas19/go-oauth2-server/store"
	"github.com/stretchr/testify/assert"
)

func TestAuthorize(t *testing.T) {
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()

	mockConsentService := mocks.NewMockUserConsentService(ctrl)
	mockUserRepository := mocks.NewMockUserRepository(ctrl)
	mockOauthClientService := mocks.NewMockOauthClientService(ctrl)
	mockAuthRepository := mocks.NewMockAuthorizationRepository(ctrl)
	mockSessionService := mocks.NewMockSessionService(ctrl)

	authService := services.NewAuthorizationService(mockOauthClientService, mockConsentService, mockAuthRepository, mockSessionService, mockUserRepository)

	t.Run("client not found", func(t *testing.T) {
		testClientNotFound(t, authService, mockOauthClientService)
	})

	t.Run("unsupported response type", func(t *testing.T) {
		testUnsupportedResponseType(t, authService, mockOauthClientService)
	})

	t.Run("invalid redirect uri", func(t *testing.T) {
		testInvalidRedirectUri(t, authService, mockOauthClientService)
	})

	t.Run("session does not exist", func(t *testing.T) {
		testSessionDoesNotExist(t, authService, mockOauthClientService, mockSessionService)
	})

	t.Run("success", func(t *testing.T) {
		testSuccess(t, authService, mockOauthClientService, mockSessionService, mockUserRepository, mockAuthRepository)
	})
}

func testClientNotFound(t *testing.T, authService services.AuthorizationService, mockOauthClientService *mocks.MockOauthClientService) {
	mockOauthClientService.EXPECT().FindOauthClient("client_id").Return(nil, errors.New("client not found"))

	command := &services.AuthorizeCommand{
		ClientId:     "client_id",
		Scope:        "scope",
		RedirectUri:  "https://example.com",
		ResponseType: responsetype.Code,
		SessionId:    "session_id",
		State:        "state",
	}

	got, err := authService.Authorize(command)
	assert.Nil(t, got)
	assert.EqualError(t, err, "failed to retrieve client: client not found")
}

func testUnsupportedResponseType(t *testing.T, authService services.AuthorizationService, mockOauthClientService *mocks.MockOauthClientService) {
	mockOauthClientService.EXPECT().FindOauthClient("client_id").Return(&store.OauthClient{
		ClientId:     "client_id",
		RedirectURIs: []string{"https://example.com"},
	}, nil)

	command := &services.AuthorizeCommand{
		ClientId:     "client_id",
		Scope:        "scope",
		RedirectUri:  "https://example.com",
		ResponseType: responsetype.Token,
		SessionId:    "session_id",
		State:        "state",
	}

	got, err := authService.Authorize(command)
	assert.Nil(t, got)
	assert.EqualError(t, err, "the authorization server does not support obtaining an authorization code using this method")
}

func testInvalidRedirectUri(t *testing.T, authService services.AuthorizationService, mockOauthClientService *mocks.MockOauthClientService) {
	mockOauthClientService.EXPECT().FindOauthClient("client_id").Return(&store.OauthClient{
		ClientId:     "client_id",
		RedirectURIs: []string{"https://example.com"},
	}, nil)

	command := &services.AuthorizeCommand{
		ClientId:     "client_id",
		Scope:        "scope",
		RedirectUri:  "https://invalid.com",
		ResponseType: responsetype.Code,
		SessionId:    "session_id",
		State:        "state",
	}

	got, err := authService.Authorize(command)
	assert.Nil(t, got)
	assert.EqualError(t, err, "redirect URI is not registered for client")
}

func testSessionDoesNotExist(t *testing.T, authService services.AuthorizationService, mockOauthClientService *mocks.MockOauthClientService, mockSessionService *mocks.MockSessionService) {
	mockOauthClientService.EXPECT().FindOauthClient("client_id").Return(&store.OauthClient{
		ClientId:     "client_id",
		RedirectURIs: []string{"https://example.com"},
	}, nil)
	mockSessionService.EXPECT().SessionExists("session_id").Return(false)

	command := &services.AuthorizeCommand{
		ClientId:     "client_id",
		Scope:        "scope",
		RedirectUri:  "https://example.com",
		ResponseType: responsetype.Code,
		SessionId:    "session_id",
		State:        "state",
	}

	got, err := authService.Authorize(command)
	assert.Nil(t, got)
	assert.EqualError(t, err, "user not authenticated")
}

func testSuccess(t *testing.T, authService services.AuthorizationService, mockOauthClientService *mocks.MockOauthClientService, mockSessionService *mocks.MockSessionService, mockUserRepository *mocks.MockUserRepository, mockAuthRepository *mocks.MockAuthorizationRepository) {
	mockOauthClientService.EXPECT().FindOauthClient("client_id").Return(&store.OauthClient{
		ClientId:     "client_id",
		RedirectURIs: []string{"https://example.com"},
	}, nil)
	mockSessionService.EXPECT().SessionExists("session_id").Return(true)
	mockSessionService.EXPECT().GetUserIdFromSession("session_id").Return("user_id", nil)
	mockUserRepository.EXPECT().FindByUserId("user_id").Return(&store.User{
		Id: "user_id",
	}, nil)

	mockAuthRepository.EXPECT().Save(gomock.Any()).Return(&store.AuthCode{
		Code:        "auth_code",
		ClientId:    "client_id",
		RedirectURI: "https://example.com",
		Scope:       "scope",
		CreatedAt:   time.Now(),
		ExpiresAt:   time.Now().Add(configuration.AuthCodeExpireTime),
	}, nil)

	command := &services.AuthorizeCommand{
		ClientId:     "client_id",
		Scope:        "scope",
		RedirectUri:  "https://example.com",
		ResponseType: responsetype.Code,
		SessionId:    "session_id",
		State:        "state",
	}

	expected := &oauth.AuthCode{
		Code:        "auth_code",
		ClientId:    "client_id",
		RedirectURI: "https://example.com",
		Scope:       "scope",
		CreatedAt:   time.Now(),
		ExpiresAt:   time.Now().Add(configuration.AuthCodeExpireTime),
	}

	got, err := authService.Authorize(command)
	assert.NoError(t, err)
	if !expected.Equal(got) {
		t.Errorf("expected and actual AuthCode are not equal")
	}
}
